# 深度学习

### 数据集划分

如图1.1，数据集中包含3000张真实场景下行车记录仪采集的图片， 其中训练集包含2600张带有标签的图片，测试集包含400张不带有标签的测试集图片。数据集中共有22种细分的人车类型标签。其中，yolov5支持yolo的.txt标签格式，故将json的标签格式先转化为yolo格式，即标签、xy中心坐标、物体宽高，其中后四者均为归一化后的坐标。

在划分训练集和测试集时，以8：2划分训练集和测试集，并采用随机划分的方式，保证数据集的随机性。

|      |                                       |
| ---- | ------------------------------------- |
|      | ![](/imgs/clip_image002-1669519970038.jpg) |

> 图1.1 数据集样例图

### 数据增强

获得一个表现良好的神经网络模型，往往需要大量的数据作支撑，然而获取新的数据这项工作往往需要花费大量的时间与人工成本。使用数据增强技术，可以充分利用计算机来生成数据，增加数据量，如采用缩放、平移、旋转、色彩变换等方法增强数据，数据增强的好处是能够增加训练样本的数量，同时添加合适的噪声数据，能够提高模型的泛化力。

YOLOv5提供了多种数据增强的方式，除了一些最基本的缩放、裁剪、旋转以外，还提供了Mosaic方法。其主要思想就是将 4 张图片进行随机裁剪、缩放后，再随机排列拼接形成一张图片，实现丰富数据集的同时，增加了小样本目标，提升网络的训练速度。在进行归一化操作时会一次性计算4张图片的数据，因此模型对内存的需求降低。如此一来，小目标的AP值会大大提高。

|      |                                          |
| ---- | ---------------------------------------- |
|      | ![img](/clip_image004-1669519970038.gif) |

> 图1.2 Mosaic数据增强流程

在此次训练中，batch_size取为16。

|      |                                          |
| ---- | ---------------------------------------- |
|      | ![img](/clip_image006-1669519970039.jpg) |

> 图1.3 batch为16的Mosaic数据增强效果图

### 损失函数

[损失函数](https://so.csdn.net/so/search?q=损失函数&spm=1001.2101.3001.7020)是用来衡量模型预测值和真实值不一样的程度，极大程度上决定了模型的性能。

 与往届YOLO类似，YOLOv5损失函数由 3 个部分组成，分别为bbox回归损失、目标置信度损失和类别损失。网络每个将特征图分为若干个cell，每个cell输出一个[*tx*,*ty*,*tw*,*th*,*po*,*c*1,*c*2,...]的向量，其中*tx*,*ty*用于计算预测框和对应anchor box (也就是所在cell) 两者中心的偏移量，*tw*,*th*用于计算预测狂的宽高，po是该cell (预测框) 含有目标的概率，c1,c2…为对应类别的预测值。 

 三个部分的损失均是通过匹配到的正样本对来计算，每一个输出特征图相互独立，直接相加得到最终每一部分的损失值。

  ![img](/clip_image008-1669519970039.gif)  

其中，K,S2分别为输出特征图、cell和每个cell上anchor的数量；α为对应项的权重，在hyp.scratch-high.yaml中默认值取为![img](E:\图片\Typora_image\clip_image010-1669519970039.gif)；![img](E:\图片\Typora_image\clip_image012-1669519970039.gif)表示第K个输出特征图，第i个cell，第j个anchor box是否为正样本，如果是正样本则为1，反之为0；tp，tgt是预测向量和ground-truth向量；![img](E:\图片\Typora_image\clip_image014-1669519970039.gif)用于平衡每个尺度的输出特征图的权重，默认取值为[4.0,1.0,0.4]，依次对应80×80，40×40，20×20的输出特征图。

### 网络结构

YOLOv5网络部分主要由以下几部分组成：

Ø Backbone：New CSP-Darknet53

Ø Neck:SPPF, New CSP-PAN

Ø Head:YOLOv3 Head

在Neck部分，首先是将SPP换成了SPPF，两者作用一样，但SPPF效率更高，SPPF是将输入串行通过多个5×5大小的MaxPool层，其中，两个5×5大小的MaxPool层和一个13×13的Maxpool层计算结果是一样的。

 

 

![img](/clip_image016-1669519970039.gif)

> 图1.4 SPPF层结构

 

![img](/clip_image018-1669519970039.gif)

> 图1.5 YOLOv5网络结构

### 后处理

为处理同一目标的多余方框，采用NMS（非极大值抑制）的方法。步骤如下：

(1) 获取当前目标类别下所有bbx的信息；

(2) 将bbx按照confidence从高到低排序,并记录当前confidence最大的bbx；

(3) 计算最大confidence对应的bbx与剩下所有的bbx的IOU,移除所有大于IOU阈值的bbx；

(4) 对剩下的bbx，循环执行(2)和(3)直到所有的bbx均满足要求（即不能再移除bbx）。



### 性能评估

![img](/clip_image020-1669519970039.gif)

> 图1.6 训练指标随epoch的变化

通过训练结果图可知，训练集和验证集的各项损失逐渐下降趋于0；精确度为74.65，召回率为51.96；最终的mAP值达到60.472，相较于官方yolov5s.pt的mAP=56.8提高了提升了近3.7左右，满足需求。

# WEB前后端

本次设计采取的是Python的一个轻量级web框架：Flask。该框架中通过创建路由并关联函数，实现网页。

在网页前端，通过POST的请求方法，传递图片给后端，后端在收到图片后，将图片传递给yolov5的推理函数中，并返回预测信息和图片，再传递到网页前端。

在使用时，程序实例需要知道每个url请求所对应的运行代码是谁。所以程序中必须要创建一个url请求地址到python运行函数的一个映射。处理url和视图函数之间的关系的程序就是"路由"，在Flask中，路由是通过@app.route装饰器(以@开头)来表示的。

|      |                                          |
| ---- | ---------------------------------------- |
|      | ![img](/clip_image022-1669519970039.jpg) |

> 图2.1 网页前端

|      |                                          |
| ---- | ---------------------------------------- |
|      | ![img](/clip_image024-1669519970039.jpg) |

> 图2.2 结果展示

返回结果中，包括检测出的类别、类别大小、置信度。

# Redis缓存

Redis是一个基于内存存储的非结构化数据库,以高I/O性能和高响应速度著称,在数据缓冲、消息队列、Key-Value存储等场景都发挥着重要的作用。随着网络用户访问量的不断增加,Web服务器的压力成倍增加,会导致服务器宕机和数据库崩溃等问题。

对于相同的请求，可以不用再次预测，于是对每张预测的图片都以哈希的数据结构，Base64编码形式存储进Redis，并设置一定的过期时间，当用户在过期时间内请求目标时，便可直接从Redis缓存中取出数据直接上传，进而降低了服务器和显卡Cuda的压力。

通过结果可以看到，在相同请求的时候，采用Yolov5预测和直接调用Redis缓存，速度相差了近3倍左右。

![img](/clip_image026-1669519970039.jpg) 

> 图3.1 调用Redis缓存的时间
